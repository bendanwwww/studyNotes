简单动态字符串(simple dynamic string SDS)
SDS结构 int len(已占用空间长度) int free(空闲空间长度) char buf[](字符数组) 为了使用c的字符串类库 SDS字符串结尾默认写入一个不计入总空间的空字符'\0'
当buf需要扩容时 若此时数组长度小于1M 则扩展和len相同的长度 若大于1M 则扩展1M长度
当buf中的字符减少时不会立刻缩容 可以通过显示的调用api进行空间释放
对比c字符串 SDS减少了频繁申请内存的操作 申请内存动作对用户无感知 减少了内存溢出和泄露的风险 同时字符串长度使用len变量保存 提高了效率
    总体上讲 SDS比c字符串效率更高(申请内存动作 字符串长度读取)且可以存放更丰富的数据('\0'不作为字符串结尾的标识 可以存放带空字符的二进制文本) 这是redis使用其代替c字符串的原因

链表(双向链表)
链表节点结构 struct ListNode *prev(前置节点) struct ListNode *next(后置节点) void *value(值 任意类型)
链表结构 head(头节点) tail(尾结点) len(链表长度) dup(复制函数) free(释放空间函数) match(节点比较函数) 由于链表节点值类型不确定 需要实现不同的复制/释放空间/比较函数

字典(hash表)
dictht结构(redis hash表结构) table(hash数组) size(数组长度) sizemask(hash表大小掩码 size - 1) used(已保存元素个数)
dict结构(redis 字典数据结构) type(存储元素类型) privdata(存储元素实现的函数 计算hash值/复制/释放空间/比较) ht[2](两个dicttht 用于rehash) trehashidx(是否正在进行rehash -1 不在进行 0 正在进行)
redis的hash冲突使用链表解决
当一个hash数组的负载因子(已保存元素个数/数组总长度) 在未进行aof或rdb时大于1 或在进行aof或rdb时大于5 时 进行扩容(大于used * 2最接近的2^n)
当一个hash数组的负载因子小于0.1时进行缩容(小于used 最接近的2^n)
渐进式rehash 当进行扩缩容时 将trehashidx置为0 当执行插入/更新/删除操作时 将数组此下标下链表元素迁移至ht[1]中 直至全部迁移完成 将ht[0]指向ht[1] 将ht[1]指向一个大小与ht[0]一样的新创建的空dictht 最后将trehashidx置回-1 
在rehash时 插入操作全部插入至ht[1] 查询时先查询ht[0] 若查不到则查询ht[1]

跳跃表(skip list)
redis跳跃表有一个zskiplist和多个skiplistnode组成 
zskiplist维护了表的头尾节点指针 表节点的数量 表最大层级
skiplistnode维护了一个节点的score值(对象排序 若score相同则按对象字典序) 具体对象 所处层级 前进指针(指向相同层级的下一个元素)和前进指针跨度(跨度标识相同层级的下一个元素和当前元素中间有几个元素 若相邻则为1 以此类推) 后退指针
redis跳表中的每个值根据score值大小随机一个1-32的层级(score值越大 大层级的概率越大)

整数集合(intlist)
redis可以使用一个整数数组保存一个有序的整数集合
整数集合包括一个整数数组 数组长度 整数类型(16位 32位 64位整数)
当在一个短位数数组中插入一个长位数整数时(16位数组插入32位整数) 整数数组会进行升级操作 将所有元素扩充成长位数(16位扩充成32位) 整数数组并不会进行降级操作
当一个集合元素较少且均为整数时 使用整数集合可以节省内存空间且修改和查询的时间复杂度尚可接受

压缩列表(ziplist)
redis可以申请一片连续的内存空间 用于保存整数或字符串集合
压缩链表包括 zlbytes(内存空间长度) zltail(压缩列表最后一个节点的相对位置) zllen(节点数量) zlend(压缩列表结束标识) 若干个entryX(压缩列表节点数据结构)
每个entryX包括 previous_entry_length(上一个节点的长度 用于从后往前遍历列表) encoding(节点数据类型) content(节点数据 可能为字节数组或整数)
当进行插入或删除操作时 时间复杂度可能为O(n)(需要对后续节点依次后推或前移) 也可能为O(n^2)(连锁更新 由于previous_entry_length记录的前一个节点长度可能为1字节或5字节 节点长度过长可能使用5字节 当某一个节点的长度需要从1字节扩展至5字节且前序节点长度都在扩展临界值时 会发生连锁更新)
当一个集合元素较少且元素长度较短时 使用压缩列表可以节省内存空间且对集合操作的平均时间复杂度为O(n) 尚可接受

redis支持对象(string 字符串对象 list 列表对象 hash 哈希对象 set 集合对象 zset 有序集合对象)
redis的每一个键值都被包装成了一个redisobject对象 其中包括 type(对象类型 string list hash 等) encoding(对象编码 实现的数据结构类型 跳跃表 压缩列表 embstr编码的字符串等) ptr(指向底层数据结构的指针 指向真正存储数据的结构) refcount(引用计数器 记录此对象被引用的数量) lru(记录此对象最后一次被访问的时间戳)
string 字符串对象
    有int raw embstr 三种数据结构的实现
    若字符串为一个整数 则使用int类型的编码 将字符串以数字形式保存(节省内存和编解码时间)
    若字符串较短(小于等于32个字节) 则使用embstr数据结构(申请一片连续的内存 保存redisobject对象和embstr对象 节省了申请内存的时间 且因为空间连续 可以更有效的使用cpu缓存)
    若字符串不是一个整数且大于32个字节 则使用raw类型(SDS 简单动态字符串 编码格式与embstr相同 和redisobject对象分开申请内存)
    当int类型编码被修改成一个非整数字符串或执行了处理字符串相关函数(类似append subindex等) 会被转换成raw类型编码
    当embstr类型编码被修改(embstr为只读 避免修改时重新申请内存空间的开销) 会被转换成raw编码
    在redis其他对象中保存的字符串 均使用了类型为string的redisobject
list 列表对象
    有ziplist linkedlist 两种数据结构实现
    若一个列表的长度小于512个且每个元素的大小小于64字节 则使用ziplist(压缩列表 申请连续的内存空间 开销较小 但插入效率较低 不适合元素较多的场景) 否则使用linkedlist(双向链表)
    当ziplist类型的数据结构被修改时有任意一个条件不被满足 则转换为linkedlist
hash 哈希对象
    有ziplist hashtable 两种数据结构实现
    若一个hash字典保存的元素小于512个且每个元素大小小于64字节 则使用ziplist(每个元素在压缩列表中占两个连续的entryX 第一个保存hash key 第二个保存hash value)
    若一个hash字典保存的元素大于等于512个或有元素大小大于等于64字节 则使用hashtable
    当ziplist类型的数据结构被修改 不满足上述条件时 则转换成hashtable
set 集合对象
    有intlist hashtable 两种数据结构实现
    若一个set中只包含整数且元素个数小于512 则使用intset集合 否则使用hashtable(value为null)
    当intlist类型的数据结构被修改 不满足上述条件时 则转换成hashtable
zset 有序集合对象
    有ziplist skiplist+hashtable 两种数据结构实现
    若zset保存的元素小于128个且每个元素长度小于64字节 则使用ziplist(每个元素在压缩列表中占两个连续的entryX 第一个保存元素值 第二个保存元素score 在压缩列表中以score从小到大排序)
    若zset保存的元素大于等于128个或有元素长度大于64字节 则使用skiplist+hashtable(在hashtable中保存了元素值和score的键值对 方便查询元素的score)

当一个对象没有任何引用的时候(redisobject refcount为0) 则此对象可以被回收(定时任务采样 内存不足时)
redis启动时创建了0-9999的字符串对象 当有对象需要引用时 共享这些被创建好的对象 其他类型的对象不支持共享(比较对象是否相等的时间复杂度过高)

redis过期策略

RDB
保存了在某一时刻的redis数据库快照 使用save(主线程执行 阻塞)或bgsave(fork子线程)两种命令执行
由一个saveparam结构保存触发执行的条件(距上次执行间隔n秒or距上次执行服务器执行了m次数据修改)
由一个redisserver结构保存了上一次执行bgsave的时间和服务器数据修改的次数
由servercorn(redis唯一时间事件 默认1s执行10次)定时检查是否满足条件

AOF
保存了redis服务器执行的命令语句 崩溃还原时通过伪造一个无网络连接的客户端执行aof保存的命令即可还原redis崩溃前的状态
aof通过重写机制来控制aof文件的大小(将修改同一条数据的多条命令合成一条 去除已过期的命令)
aof重写不阻塞主线程 当重写过程中有新的命令被执行时 新命令在写入原aof文件的同时写入aof缓冲区中 当重写完成后 再将缓冲区的命令写入新文件中(此时主线程阻塞)
aof持久化比rdb效率更高 数据丢失的数量较少(最多丢失一次写入的命令) 当redis崩溃还原时 优先选择aof

redis主从
redis可以通过slaveof命令 使一个redis服务成为另一个服务的从节点 在首次主从复制完成后 主节点在执行命令时会将命令同步给从节点执行
redis 2.8之前
    当从节点被建立后 主动向主节点发送sync命令 主节点会使用bgsave命令生成一个rdb文件 将rdb文件和在生成文件期间产生的命令(存在于缓冲区中)发送给从节点完成主从同步
    当丛节点掉线后 重新上线的从节点会重新发送sync命令 重新全量同步主节点数据
redis 2.8及以后
    当从节点被建立后 发送sync进行主从同步的方式不变
    主节点会将最近一段时间执行的命令维护复制积压缓冲区中 (一个FIFO队列 保存的命令数量与队列大小相关 默认1m) 
    主从会维护一个命令同步的偏移量和服务器唯一id 当主从偏移量不一致时(从节点掉线主动发送psync命令检查同步偏移量 每隔1秒从节点向主节点发送心跳检查偏移量) 若未同步的命令在复制积压缓冲区中 则直接同步 否则执行旧版本的全量同步操作
    主从心跳除了检测主从一致性之外 主节点还可以通过心跳判断从节点是否在线 当从节点数量过少或延迟过大时 可以拒绝新的写入命令

redis sentinel(redis 哨兵 监控主从集群的手段)
redis可以创建一个sentinel集群对redis的主从集群进行监控 当主节点下线时 sentinel集群可以从从节点中选取出一个新的主节点 并将其他从节点的复制关系指向新的主节点 当原主节点重新上线后 则成为新主节点的从节点
创建sentinel节点后 sentinel服务会根据配置文件与主节点创建连接(发送命令连接 用于主从变换和心跳检测 订阅连接 用于sentinel服务的主动发现和服务间主从节点的信息更新)
sentinel服务每隔10s向主节点发送info命令 获取主节点信息和下属的从节点信息 并更新自己的主从信息(维护在一个hash表中) 同时建立与从节点的链接(命令和订阅连接)
sentinel服务每隔2s向主从节点的hello频道发送消息(sentinel服务信息 主节点信息) 其他sentinel订阅hello频道消息 以此主动发现其他sentinel服务(建立命令连接 更新主从信息)
以上 sentinel与其他sentinel节点 监控的主节点和主节点下的从节点都建立了连接
sentinel节点每隔1s向监控的主从节点发送ping命令 若超过一定时间未收到回复(超时时间在配置文件中可配) 则将此节点标识为主观下线 同时向其他sentinel节点发送询问消息 若回复下线超过一定数量(其他sentinel服务标识此节点为主观或客观下线 数量在配置文件中可配) 则标记为客观下线 并发起局部首领选举
sentinel发起选举后 会向其他sentinel节点发送消息要求成为局部首领(在一次重新选择主节点的周期内有效) 若其他sentinel收到消息并在一个选举周期内未选择其他节点 则回复同意消息 若发起选举的节点收到半数以上同意消息 则成为局部首领 为监控主从集群选取新主节点
sentinel成为局部首领后 从维护的从节点信息中筛选出可用节点(未下线 上一次通信小于一定时间 与主节点连接断开小于一定时间) 根据从节点的复制偏移量大小选取一个新的主节点(相同则使用节点优先级 再相同则选取run id最小)
选出新主节点后 sentinel向该节点发送 slaveof no one命令 使其从从节点变为主节点 并向其他从节点发送slaveof命令 开始从新主节点复制
当旧主节点上线后 重新成为新主节点的从节点

redis集群
redis集群是一个去中心化的服务集群 每个节点使用hash表保存了集群中每个节点的信息(key为node name value为node info 包括ip 端口 主从标识 纪元)
一个redis集群分为16384个槽(逻辑分区 在存储上并没有特殊的含义) 每个节点负责一部分槽的维护 只有16384个槽均被指派维护后 整个集群才打到可用
每个节点使用一个16384场的数组记录自己维护的槽(根据下标 为0则不维护这个槽 为1则维护这个槽)
同时节点使用一个hash表记录集群所有的槽分配(存在16384个key 被同一个节点维护的槽点key的value指向同一个节点信息)
每一个key被计算一个crc-16值 % 16384 从而被分配到一个槽点
每个节点使用一个跳跃表维护自身的槽点和槽点中的key(score为槽点值 valye为key)
当客户端向集群任意一个节点查询key时 节点会在hash表中查询此节点是否被自身维护 若自身维护 则直接返回 否则返回一个moved错误 并返回目标节点的地址 客户端根据错误重定向至正确的节点
当节点需要进行槽点转移时 会将槽点中的key原子性的转移至新节点 当槽点转移过程中槽点的key被访问 则原节点会寻找该key是否还在自身槽点中 若是则直接返回 若不是则返回ask错误 并返回目标节点的地址 客户端首先向新节点发送asking命令 然后向新节点访问key(槽点在转移过程中 逻辑上仍属于原节点 若不发送asking命令 新节点会返回moved错误)
集群中的每个节点可以有一个主节点和多个从节点组成 每个主节点都会定时向其他节点发送ping消息 当超过一定时间未收到正确响应时 将目标节点标记为主观下线 并向其他主节点发送查询消息 若超过半数的主节点返回目标节点下线(主观或客观下线) 则在自己的节点信息表中标识节点为客观下线 并发送节点下线消息
当主节点下的从节点发现主节点下线时 会向其他主节点发送选举消息 若收到半数以上主节点的投票 则将自身升级为主节点并继承原主节点的槽点信息(raft算法)
集群中所有节点通信均通过消息发布订阅模型实现

redis锁

redis线程模型
redis实现了io多路复用用于接收客户端请求 使用reactor(反应堆)模式单线程的处理事件 
客户端套接字产生的文件事件 分发至对应的文件处理器(连接应答处理器 命令请求处理器 命令回复处理器 连接关闭处理器等)
服务本身产生的时间事件(定时任务等) 分发至时间处理器 时间事件会根据产生的顺序组成一个链表 事件分派器会遍历链表 找到一个离当前时间最近的时间事件并准备处理
事件分派器的处理过程
    遍历时间事件链表 找到一个最近需要执行的事件
    与当前时间的差值作为当前循环的阻塞时间(若差值为0则不需要阻塞)
    在阻塞过程中如果出现文件事件则结束阻塞立刻处理
    处理完成文件事件或阻塞时间结束后处理时间事件(由于先处理文件事件 可能导致时间事件的处理时间比预期的处理时间晚)
    重新进入新一次循环

redis发布订阅模型

缓存实现方式(loadcache redis cdn 客户端缓存)