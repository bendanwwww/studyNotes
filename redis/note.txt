简单动态字符串(simple dynamic string SDS)
SDS结构 int len(已占用空间长度) int free(空闲空间长度) char buf[](字符数组) 为了使用c的字符串类库 SDS字符串结尾默认写入一个不计入总空间的空字符'\0'
当buf需要扩容时 若此时数组长度小于1M 则扩展和len相同的长度 若大于1M 则扩展1M长度
当buf中的字符减少时不会立刻缩容 可以通过显示的调用api进行空间释放
对比c字符串 SDS减少了频繁申请内存的操作 申请内存动作对用户无感知 减少了内存溢出和泄露的风险 同时字符串长度使用len变量保存 提高了效率
    总体上讲 SDS比c字符串效率更高(申请内存动作 字符串长度读取)且可以存放更丰富的数据('\0'不作为字符串结尾的标识 可以存放带空字符的二进制文本) 这是redis使用其代替c字符串的原因

链表(双向链表)
链表节点结构 struct ListNode *prev(前置节点) struct ListNode *next(后置节点) void *value(值 任意类型)
链表结构 head(头节点) tail(尾结点) len(链表长度) dup(复制函数) free(释放空间函数) match(节点比较函数) 由于链表节点值类型不确定 需要实现不同的复制/释放空间/比较函数

字典(hash表)
dictht结构(redis hash表结构) table(hash数组) size(数组长度) sizemask(hash表大小掩码 size - 1) used(已保存元素个数)
dict结构(redis 字典数据结构) type(存储元素类型) privdata(存储元素实现的函数 计算hash值/复制/释放空间/比较) ht[2](两个dicttht 用于rehash) trehashidx(是否正在进行rehash -1 不在进行 0 正在进行)
redis的hash冲突使用链表解决
当一个hash数组的负载因子(已保存元素个数/数组总长度) 在未进行aof或rdb时大于1 或在进行aof或rdb时大于5 时 进行扩容(大于used * 2最接近的2^n)
当一个hash数组的负载因子小于0.1时进行缩容(小于used 最接近的2^n)
渐进式rehash 当进行扩缩容时 将trehashidx置为0 当执行插入/更新/删除操作时 将数组此下标下链表元素迁移至ht[1]中 直至全部迁移完成 将ht[0]指向ht[1] 将ht[1]指向一个大小与ht[0]一样的新创建的空dictht 最后将trehashidx置回-1 
在rehash时 插入操作全部插入至ht[1] 查询时先查询ht[0] 若查不到则查询ht[1]

跳跃表(skip list)
redis跳跃表有一个zskiplist和多个skiplistnode组成 
zskiplist维护了表的头尾节点指针 表节点的数量 表最大层级
skiplistnode维护了一个节点的score值(对象排序 若score相同则按对象字典序) 具体对象 所处层级 前进指针(指向相同层级的下一个元素)和前进指针跨度(跨度标识相同层级的下一个元素和当前元素中间有几个元素 若相邻则为1 以此类推) 后退指针
redis跳表中的每个值根据score值大小随机一个1-32的层级(score值越大 大层级的概率越大)

整数集合(intlist)
redis可以使用一个整数数组保存一个有序的整数集合
整数集合包括一个整数数组 数组长度 整数类型(16位 32位 64位整数)
当在一个短位数数组中插入一个长位数整数时(16位数组插入32位整数) 整数数组会进行升级操作 将所有元素扩充成长位数(16位扩充成32位) 整数数组并不会进行降级操作
当一个集合元素较少且均为整数时 使用整数集合可以节省内存空间且修改和查询的时间复杂度尚可接受

压缩列表(ziplist)
redis可以申请一片连续的内存空间 用于保存整数或字符串集合
压缩链表包括 zlbytes(内存空间长度) zltail(压缩列表最后一个节点的相对位置) zllen(节点数量) zlend(压缩列表结束标识) 若干个entryX(压缩列表节点数据结构)
每个entryX包括 previous_entry_length(上一个节点的长度 用于从后往前遍历列表) encoding(节点数据类型) content(节点数据 可能为字节数组或整数)
当进行插入或删除操作时 时间复杂度可能为O(n)(需要对后续节点依次后推或前移) 也可能为O(n^2)(连锁更新 由于previous_entry_length记录的前一个节点长度可能为1字节或5字节 节点长度过长可能使用5字节 当某一个节点的长度需要从1字节扩展至5字节且前序节点长度都在扩展临界值时 会发生连锁更新)
当一个集合元素较少且元素长度较短时 使用压缩列表可以节省内存空间且对集合操作的平均时间复杂度为O(n) 尚可接受

redis支持对象(string 字符串对象 list 列表对象 hash 哈希对象 set 集合对象 zset 有序集合对象)
redis的每一个键值都被包装成了一个redisobject对象 其中包括 type(对象类型 string list hash 等) encoding(对象编码 实现的数据结构类型 跳跃表 压缩列表 embstr编码的字符串等) ptr(指向底层数据结构的指针 指向真正存储数据的结构) refcount(引用计数器 记录此对象被引用的数量) lru(记录此对象最后一次被访问的时间戳)
string 字符串对象
    有int raw embstr 三种数据结构的实现
    若字符串为一个整数 则使用int类型的编码 将字符串以数字形式保存(节省内存和编解码时间)
    若字符串较短(小于等于32个字节) 则使用embstr数据结构(申请一片连续的内存 保存redisobject对象和embstr对象 节省了申请内存的时间 且因为空间连续 可以更有效的使用cpu缓存)
    若字符串不是一个整数且大于32个字节 则使用raw类型(SDS 简单动态字符串 编码格式与embstr相同 和redisobject对象分开申请内存)
    当int类型编码被修改成一个非整数字符串或执行了处理字符串相关函数(类似append subindex等) 会被转换成raw类型编码
    当embstr类型编码被修改(embstr为只读 避免修改时重新申请内存空间的开销) 会被转换成raw编码
    在redis其他对象中保存的字符串 均使用了类型为string的redisobject
list 列表对象
    有ziplist linkedlist 两种数据结构实现
    若一个列表的长度小于512个且每个元素的大小小于64字节 则使用ziplist(压缩列表 申请连续的内存空间 开销较小 但插入效率较低 不适合元素较多的场景) 否则使用linkedlist(双向链表)
    当ziplist类型的数据结构被修改时有任意一个条件不被满足 则转换为linkedlist
hash 哈希对象
    有ziplist hashtable 两种数据结构实现
    若一个hash字典保存的元素小于512个且每个元素大小小于64字节 则使用ziplist(每个元素在压缩列表中占两个连续的entryX 第一个保存hash key 第二个保存hash value)
    若一个hash字典保存的元素大于等于512个或有元素大小大于等于64字节 则使用hashtable
    当ziplist类型的数据结构被修改 不满足上述条件时 则转换成hashtable
set 集合对象
    有intlist hashtable 两种数据结构实现
    若一个set中只包含整数且元素个数小于512 则使用intset集合 否则使用hashtable(value为null)
    当intlist类型的数据结构被修改 不满足上述条件时 则转换成hashtable
zset 有序集合对象
    有ziplist skiplist+hashtable 两种数据结构实现
    若zset保存的元素小于128个且每个元素长度小于64字节 则使用ziplist(每个元素在压缩列表中占两个连续的entryX 第一个保存元素值 第二个保存元素score 在压缩列表中以score从小到大排序)
    若zset保存的元素大于等于128个或有元素长度大于64字节 则使用skiplist+hashtable(在hashtable中保存了元素值和score的键值对 方便查询元素的score)

当一个对象没有任何引用的时候(redisobject refcount为0) 则此对象可以被回收(定时任务采样 内存不足时)
redis启动时创建了0-9999的字符串对象 当有对象需要引用时 共享这些被创建好的对象 其他类型的对象不支持共享(比较对象是否相等的时间复杂度过高)

redis过期策略

RDB
保存了在某一时刻的redis数据库快照 使用save(主线程执行 阻塞)或bgsave(fork子线程)两种命令执行
由一个saveparam结构保存触发执行的条件(距上次执行间隔n秒or距上次执行服务器执行了m次数据修改)
由一个redisserver结构保存了上一次执行bgsave的时间和服务器数据修改的次数
由servercorn(redis唯一时间事件 默认1s执行10次)定时检查是否满足条件

AOF
保存了redis服务器执行的命令语句 崩溃还原时通过伪造一个无网络连接的客户端执行aof保存的命令即可还原redis崩溃前的状态
aof通过重写机制来控制aof文件的大小(将修改同一条数据的多条命令合成一条 去除已过期的命令)
aof重写不阻塞主线程 当重写过程中有新的命令被执行时 新命令在写入原aof文件的同时写入aof缓冲区中 当重写完成后 再将缓冲区的命令写入新文件中(此时主线程阻塞)
aof持久化比rdb效率更高 数据丢失的数量较少(最多丢失一次写入的命令) 当redis崩溃还原时 优先选择aof

redis集群

redis锁

redis线程模型
redis实现了io多路复用用于接收客户端请求 使用reactor(反应堆)模式单线程的处理事件 
客户端套接字产生的文件事件 分发至对应的文件处理器(连接应答处理器 命令请求处理器 命令回复处理器 连接关闭处理器等)
服务本身产生的时间事件(定时任务等) 分发至时间处理器 时间事件会根据产生的顺序组成一个链表 事件分派器会遍历链表 找到一个离当前时间最近的时间事件并准备处理
事件分派器的处理过程
    遍历时间事件链表 找到一个最近需要执行的事件
    与当前时间的差值作为当前循环的阻塞时间(若差值为0则不需要阻塞)
    在阻塞过程中如果出现文件事件则结束阻塞立刻处理
    处理完成文件事件或阻塞时间结束后处理时间事件(由于先处理文件事件 可能导致时间事件的处理时间比预期的处理时间晚)
    重新进入新一次循环

redis发布订阅模型

缓存实现方式(loadcache redis cdn 客户端缓存)